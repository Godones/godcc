# C语言子集编译器godcc

## 支持的语法

1. 一元运算

```
+/-/++/--/!
```

2. 二元运算

```
+ - * / % == != && ||  >= <= > <
```

3. 整数变量+整数常量+数组

```c
int a;
const int a;
int a[2][4];
```

4. while+for循环

```c
while(){}
for(int i=0;;){}
```

5. 函数

```c
int add(){}
int main(){
	int a = add();
}
```

函数目前不支持前置声明。其中有三个系统调用函数在语义分析阶段加入符号表中，这三个函数在模拟器中打印和输入使用，分别时`Mars_PrintInt`,`Mars_GetInt`,`Mars_PrintStr`

6. 字符串

```c
Mars_PrintStr("hello world!\n");
```

当前只支持在函数参数中出现字符串，并且只有`Mars_Print`有效，因为其它函数体内无法识别字符串有关。

7. 嵌套作用域+全局变量

```c
int a;
int b[2];
int main(){
	int a = 2;
	{
		int a = 2;
	}
}
```



## 词法分析与语法分析

使用Flex+bison完成具体的工作，具体的语法规范位于doc/SysY语言定义，并在其基础上加入了`for`循环和`++/--`以及一个字符串，其它内容一致。

## 语义分析

目前编译器能识别的错误较少，包括以下错误可以被识别

- 变量使用前是否进行了定义
- 变量是否存在重复定义
- break 语句是否在循环语句中使用
- 函数调用的参数个数和类型是否匹配
- continue 语句是否在循环语句中使用
- 函数是否重复定义
- 数组是否可以确定大小
- ....

在语义分析阶段会生成符号表，并按照作用域记录相关信息，此符号表也会在中间代码生成中被使用。

## 中间代码生成

以类似于LLVM的中间代码格式输出。

```
%2 = Load @a1 / Load %1
store @a1/ store %1
%3 = add/sub/... %1/imm,%2/imm
@a1 = alloc i32 / alloc i32 [5,5]
@a1 = globalAlloc i32 /globalAlloc i32[5,5],{1,2,3}
%2 = getElementPtr @a1,3,imm
jump %1/label
branch %1,label,label
....
```

## 目标代码生成

翻译生成的中间代码。面向的目标平台为mips32。完成寄存器分配与栈帧管理。寄存器分配算法使用最简单的分配方法(虽然分配了但是感觉没分配)，所有的变量都不会与寄存器强绑定，在中间代码的生成中所有的变量使用都会被load，因此目标代码中也就会生成这些load，即使变量已经被加载到寄存器中，为了可以使寄存器可以被重复使用，在生成相关指令时寄存器很多会被回收，比如一个生成一个`add $7,$8,$9`，其中8号9号寄存器马上就会被回收，因为后面他们将不会被使用到，同理其它指令也有相关处理。

## 项目结构

### frotend

包含词法分析、语法分析的flex,bison文件。定义的AST节点，词法分析会生成token文件，语法分析构建语法树， 在linux下使用`dot`工具可以将输出转化成抽象语法树和具体语法树。以及语义分析和生成中间代码。

### IR

包含中间代码结构定义，以及打印中间代码。

### backend

包含寄存器分配，栈帧管理，目标代码生成器实现。

### tools

程序日志`ERROR ` `INFO`...  、抽象语法树的可视化表示以及外部库njson。

### test

目录下的`nc_test`为最终的测试程序，总共8个，包括冒泡排序，快速排序，斐波那契等。



## 项目使用

项目使用cmake构建。可以使用`./main -h`查看帮助。如果需要查看生成的CST与AST，需要确保系统上按照相应工具，linux上有`dot`，windows上有`graphviz`，指定参数输出dot文件，通过上述两个软件可以将其转为pdf文件。







